import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { Document, DocumentStatus, DocumentMetadata } from '../../types';
import { createPersistentStore } from './utils/persistent-store';
import { createAsyncActions, AsyncState, createOptimisticUpdate } from './utils/async-actions';

interface DocumentState extends AsyncState {
  // Document data
  documents: Document[];
  currentDocument: Document | null;
  recentDocuments: Document[];
  
  // Filters and search
  searchQuery: string;
  filterStatus: DocumentStatus | 'all';
  sortBy: 'updatedAt' | 'createdAt' | 'title' | 'wordCount';
  sortOrder: 'asc' | 'desc';
  
  // Document actions
  setCurrentDocument: (document: Document | null) => void;
  createDocument: (title: string, content?: string) => Promise<Document | null>;
  updateDocument: (id: string, updates: Partial<Document>) => Promise<Document | null>;
  deleteDocument: (id: string) => Promise<boolean>;
  duplicateDocument: (id: string) => Promise<Document | null>;
  
  // Content actions
  updateContent: (id: string, content: string) => void;
  updateMetadata: (id: string, metadata: Partial<DocumentMetadata>) => void;
  addTag: (id: string, tag: string) => void;
  removeTag: (id: string, tag: string) => void;
  
  // Bulk actions
  bulkDelete: (ids: string[]) => Promise<boolean>;
  bulkUpdateStatus: (ids: string[], status: DocumentStatus) => Promise<boolean>;
  
  // Search and filter
  setSearchQuery: (query: string) => void;
  setFilterStatus: (status: DocumentStatus | 'all') => void;
  setSorting: (sortBy: DocumentState['sortBy'], sortOrder: DocumentState['sortOrder']) => void;
  
  // Data management
  loadDocuments: () => Promise<Document[]>;
  addToRecent: (document: Document) => void;
  clearRecent: () => void;
  
  // Async actions
  asyncActions: ReturnType<typeof createAsyncActions>;
  optimisticUpdate: ReturnType<typeof createOptimisticUpdate>;
}

const initialState = {
  documents: [],
  currentDocument: null,
  recentDocuments: [],
  searchQuery: '',
  filterStatus: 'all' as const,
  sortBy: 'updatedAt' as const,
  sortOrder: 'desc' as const,
  isLoading: false,
  error: null,
};

export const useDocumentStore = create<DocumentState>()(
  persist(
    (set, get) => {
      const asyncActions = createAsyncActions(set, get);
      const optimisticUpdate = createOptimisticUpdate(set, get);
      
      return {
        ...initialState,
        asyncActions,
        optimisticUpdate,
        
        // Basic setters
        setCurrentDocument: (document: Document | null) => {
          set({ currentDocument: document });
          if (document) {
            get().addToRecent(document);
          }
        },
        
        // Document CRUD operations
        createDocument: async (title: string, content = '') => {
          return asyncActions.execute(async () => {
            // TODO: Replace with actual API call
            const newDocument: Document = {
              id: `doc_${Date.now()}`,
              title,
              content,
              metadata: {
                wordCount: content.split(/\s+/).filter(Boolean).length,
                readingTime: Math.ceil(content.split(/\s+/).filter(Boolean).length / 200),
                language: 'en',
              },
              status: 'draft',
              tags: [],
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
              userId: 'current-user-id', // TODO: Get from user store
            };
            
            set((state) => ({
              documents: [newDocument, ...state.documents],
              currentDocument: newDocument,
            }));
            
            get().addToRecent(newDocument);
            return newDocument;
          });
        },
        
        updateDocument: async (id: string, updates: Partial<Document>) => {
          return optimisticUpdate(
            (state) => ({
              documents: state.documents.map((doc) =>
                doc.id === id
                  ? { ...doc, ...updates, updatedAt: new Date().toISOString() }
                  : doc
              ),
              currentDocument:
                state.currentDocument?.id === id
                  ? { ...state.currentDocument, ...updates, updatedAt: new Date().toISOString() }
                  : state.currentDocument,
            }),
            async () => {
              // TODO: API call
              // await documentAPI.update(id, updates);
              return updates as Document;
            }
          );
        },
        
        deleteDocument: async (id: string) => {
          return optimisticUpdate(
            (state) => ({
              documents: state.documents.filter((doc) => doc.id !== id),
              currentDocument: state.currentDocument?.id === id ? null : state.currentDocument,
              recentDocuments: state.recentDocuments.filter((doc) => doc.id !== id),
            }),
            async () => {
              // TODO: API call
              // await documentAPI.delete(id);
              return true;
            }
          );
        },
        
        duplicateDocument: async (id: string) => {
          return asyncActions.execute(async () => {
            const original = get().documents.find((doc) => doc.id === id);
            if (!original) throw new Error('Document not found');
            
            const duplicate: Document = {
              ...original,
              id: `doc_${Date.now()}`,
              title: `${original.title} (Copy)`,
              createdAt: new Date().toISOString(),
              updatedAt: new Date().toISOString(),
            };
            
            set((state) => ({
              documents: [duplicate, ...state.documents],
            }));
            
            return duplicate;
          });
        },
        
        // Content actions
        updateContent: (id: string, content: string) => {
          const wordCount = content.split(/\s+/).filter(Boolean).length;
          const readingTime = Math.ceil(wordCount / 200);
          
          set((state) => ({
            documents: state.documents.map((doc) =>
              doc.id === id
                ? {
                    ...doc,
                    content,
                    metadata: { ...doc.metadata, wordCount, readingTime },
                    updatedAt: new Date().toISOString(),
                  }
                : doc
            ),
            currentDocument:
              state.currentDocument?.id === id
                ? {
                    ...state.currentDocument,
                    content,
                    metadata: { ...state.currentDocument.metadata, wordCount, readingTime },
                    updatedAt: new Date().toISOString(),
                  }
                : state.currentDocument,
          }));
        },
        
        updateMetadata: (id: string, metadata: Partial<DocumentMetadata>) => {
          set((state) => ({
            documents: state.documents.map((doc) =>
              doc.id === id
                ? {
                    ...doc,
                    metadata: { ...doc.metadata, ...metadata },
                    updatedAt: new Date().toISOString(),
                  }
                : doc
            ),
            currentDocument:
              state.currentDocument?.id === id
                ? {
                    ...state.currentDocument,
                    metadata: { ...state.currentDocument.metadata, ...metadata },
                    updatedAt: new Date().toISOString(),
                  }
                : state.currentDocument,
          }));
        },
        
        addTag: (id: string, tag: string) => {
          set((state) => ({
            documents: state.documents.map((doc) =>
              doc.id === id && !doc.tags.includes(tag)
                ? { ...doc, tags: [...doc.tags, tag], updatedAt: new Date().toISOString() }
                : doc
            ),
            currentDocument:
              state.currentDocument?.id === id && !state.currentDocument.tags.includes(tag)
                ? {
                    ...state.currentDocument,
                    tags: [...state.currentDocument.tags, tag],
                    updatedAt: new Date().toISOString(),
                  }
                : state.currentDocument,
          }));
        },
        
        removeTag: (id: string, tag: string) => {
          set((state) => ({
            documents: state.documents.map((doc) =>
              doc.id === id
                ? {
                    ...doc,
                    tags: doc.tags.filter((t) => t !== tag),
                    updatedAt: new Date().toISOString(),
                  }
                : doc
            ),
            currentDocument:
              state.currentDocument?.id === id
                ? {
                    ...state.currentDocument,
                    tags: state.currentDocument.tags.filter((t) => t !== tag),
                    updatedAt: new Date().toISOString(),
                  }
                : state.currentDocument,
          }));
        },
        
        // Bulk actions
        bulkDelete: async (ids: string[]) => {
          return optimisticUpdate(
            (state) => ({
              documents: state.documents.filter((doc) => !ids.includes(doc.id)),
              currentDocument: ids.includes(state.currentDocument?.id || '')
                ? null
                : state.currentDocument,
              recentDocuments: state.recentDocuments.filter((doc) => !ids.includes(doc.id)),
            }),
            async () => {
              // TODO: API call
              // await documentAPI.bulkDelete(ids);
              return true;
            }
          );
        },
        
        bulkUpdateStatus: async (ids: string[], status: DocumentStatus) => {
          return optimisticUpdate(
            (state) => ({
              documents: state.documents.map((doc) =>
                ids.includes(doc.id)
                  ? { ...doc, status, updatedAt: new Date().toISOString() }
                  : doc
              ),
              currentDocument:
                ids.includes(state.currentDocument?.id || '')
                  ? { ...state.currentDocument!, status, updatedAt: new Date().toISOString() }
                  : state.currentDocument,
            }),
            async () => {
              // TODO: API call
              // await documentAPI.bulkUpdateStatus(ids, status);
              return true;
            }
          );
        },
        
        // Search and filter
        setSearchQuery: (query: string) => set({ searchQuery: query }),
        setFilterStatus: (status: DocumentStatus | 'all') => set({ filterStatus: status }),
        setSorting: (sortBy: DocumentState['sortBy'], sortOrder: DocumentState['sortOrder']) =>
          set({ sortBy, sortOrder }),
        
        // Data management
        loadDocuments: async () => {
          return asyncActions.execute(async () => {
            // TODO: API call
            // const documents = await documentAPI.list();
            // set({ documents });
            // return documents;
            
            // Mock implementation
            const mockDocuments: Document[] = [];
            set({ documents: mockDocuments });
            return mockDocuments;
          });
        },
        
        addToRecent: (document: Document) => {
          set((state) => {
            const filtered = state.recentDocuments.filter((doc) => doc.id !== document.id);
            return {
              recentDocuments: [document, ...filtered].slice(0, 10), // Keep only 10 recent
            };
          });
        },
        
        clearRecent: () => set({ recentDocuments: [] }),
      };
    },
    {
      ...createPersistentStore('documents', 1),
      partialize: (state) => ({
        recentDocuments: state.recentDocuments,
        searchQuery: state.searchQuery,
        filterStatus: state.filterStatus,
        sortBy: state.sortBy,
        sortOrder: state.sortOrder,
      }),
    }
  )
);

// Selectors with computed values
export const documentSelectors = {
  currentDocument: (state: DocumentState) => state.currentDocument,
  documents: (state: DocumentState) => state.documents,
  filteredDocuments: (state: DocumentState) => {
    let filtered = state.documents;
    
    // Apply status filter
    if (state.filterStatus !== 'all') {
      filtered = filtered.filter((doc) => doc.status === state.filterStatus);
    }
    
    // Apply search filter
    if (state.searchQuery) {
      const query = state.searchQuery.toLowerCase();
      filtered = filtered.filter(
        (doc) =>
          doc.title.toLowerCase().includes(query) ||
          doc.content.toLowerCase().includes(query) ||
          doc.tags.some((tag) => tag.toLowerCase().includes(query))
      );
    }
    
    // Apply sorting
    filtered.sort((a, b) => {
      const aValue = a[state.sortBy];
      const bValue = b[state.sortBy];
      
      if (typeof aValue === 'string' && typeof bValue === 'string') {
        const comparison = aValue.localeCompare(bValue);
        return state.sortOrder === 'asc' ? comparison : -comparison;
      }
      
      if (typeof aValue === 'number' && typeof bValue === 'number') {
        return state.sortOrder === 'asc' ? aValue - bValue : bValue - aValue;
      }
      
      return 0;
    });
    
    return filtered;
  },
  recentDocuments: (state: DocumentState) => state.recentDocuments,
  isLoading: (state: DocumentState) => state.isLoading,
  error: (state: DocumentState) => state.error,
  totalWordCount: (state: DocumentState) =>
    state.documents.reduce((total, doc) => total + doc.metadata.wordCount, 0),
  documentsByStatus: (state: DocumentState) =>
    state.documents.reduce((acc, doc) => {
      acc[doc.status] = (acc[doc.status] || 0) + 1;
      return acc;
    }, {} as Record<DocumentStatus, number>),
};