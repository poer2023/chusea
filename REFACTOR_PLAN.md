# ğŸ”„ ç³»ç»Ÿé‡æ„è®¡åˆ’ - ä»å¤šåŠŸèƒ½åŠ©æ‰‹åˆ°ä¸“ä¸šå†™ä½œå·¥å…·

## ğŸ“Š ç°çŠ¶åˆ†æ

### å½“å‰ç³»ç»Ÿæ¶æ„
```
ç°æœ‰ç³»ç»Ÿ: ä¼ ç»Ÿå¤šåŠŸèƒ½AIåŠ©æ‰‹
â”œâ”€â”€ å‰ç«¯: React 19.1.0 + Vite + Tailwind
â”œâ”€â”€ åç«¯: FastAPI + SQLAlchemy + SQLite  
â”œâ”€â”€ åŠŸèƒ½: å†™ä½œAgent + æ–‡çŒ®Agent + å·¥å…·Agent + æ–‡æ¡£ç®¡ç†
â””â”€â”€ äº¤äº’: å¤šé¡µé¢åˆ†ç¦»å¼æ“ä½œ
```

### ç›®æ ‡ç³»ç»Ÿæ¶æ„  
```
æ–°ç³»ç»Ÿ: ä¸“ä¸šAIå†™ä½œå·¥ä½œå°
â”œâ”€â”€ å‰ç«¯: Next.js 14 + Zustand + XState + TipTap
â”œâ”€â”€ åç«¯: FastAPI + PostgreSQL + Redis + ä»»åŠ¡é˜Ÿåˆ—
â”œâ”€â”€ æ ¸å¿ƒ: å¾ªç¯ç”Ÿæˆå¼•æ“ (Planâ†’Draftâ†’Checkâ†’Quality)
â””â”€â”€ äº¤äº’: å•é¡µé¢æŒç»­å·¥ä½œæµ
```

---

## ğŸ¯ é‡æ„ç›®æ ‡

### äº§å“å±‚é¢
- **ä»å¤šåŠŸèƒ½å·¥å…· â†’ ä¸“ä¸šå†™ä½œå·¥å…·**: èšç„¦é•¿æ–‡åˆ›ä½œåœºæ™¯
- **ä»æ‰‹åŠ¨æ“ä½œ â†’ è‡ªåŠ¨å¾ªç¯**: æœ€å°‘äººå·¥å¹²é¢„å®Œæˆé«˜è´¨é‡é•¿æ–‡  
- **ä»åˆ†ç¦»åŠŸèƒ½ â†’ é›†æˆå·¥ä½œæµ**: ç»Ÿä¸€çš„å†™ä½œâ†’æ ¡éªŒâ†’ä¼˜åŒ–å¾ªç¯

### æŠ€æœ¯å±‚é¢
- **ä»ä¼ ç»ŸWeb â†’ PWAå·¥ä½œå°**: æ›´å¥½çš„æ¡Œé¢åº”ç”¨ä½“éªŒ
- **ä»æ— çŠ¶æ€ â†’ çŠ¶æ€æœºé©±åŠ¨**: å¤æ‚å·¥ä½œæµçš„ç²¾ç¡®æ§åˆ¶
- **ä»å³æ—¶å“åº” â†’ æŒç»­å¤„ç†**: æ”¯æŒé•¿æ—¶é—´åå°ä»»åŠ¡

---

## ğŸš¨ å…³é”®å˜åŒ–ç‚¹

### 1. æ ¸å¿ƒä¸šåŠ¡é€»è¾‘é‡æ„ ğŸ”´
**å½±å“**: æ ¹æœ¬æ€§é‡å†™
- **ç°åœ¨**: ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©Agent â†’ å•æ¬¡å¤„ç† â†’ è¿”å›ç»“æœ
- **ç›®æ ‡**: è‡ªåŠ¨å¾ªç¯å¼•æ“ â†’ æŒç»­ä¼˜åŒ– â†’ è´¨é‡è¾¾æ ‡æ‰åœæ­¢

### 2. ç”¨æˆ·ç•Œé¢å®Œå…¨é‡æ„ ğŸ”´  
**å½±å“**: å‰ç«¯å…¨éƒ¨é‡å†™
- **ç°åœ¨**: å¤šé¡µé¢åº”ç”¨ï¼ŒåŠŸèƒ½åˆ†æ•£
- **ç›®æ ‡**: Holy Grailå•é¡µé¢å¸ƒå±€ï¼Œä¸“æ³¨å†™ä½œæµç¨‹

### 3. æ•°æ®æ¨¡å‹æ‰©å±• ğŸŸ¡
**å½±å“**: æ•°æ®åº“schemaå˜æ›´
- **ç°åœ¨**: ç®€å•æ–‡æ¡£è¡¨ + ç”¨æˆ·è¡¨
- **ç›®æ ‡**: å·¥ä½œæµèŠ‚ç‚¹ + ç‰ˆæœ¬æ ‘ + è´¨é‡æŒ‡æ ‡

### 4. æŠ€æœ¯æ ˆå‡çº§ ğŸŸ¡
**å½±å“**: éƒ¨åˆ†é‡å†™
- **ç°åœ¨**: React CSR + ä¼ ç»ŸAPI
- **ç›®æ ‡**: Next.js SSR + tRPC + PWA

---

## ğŸ“‹ é‡æ„ä»»åŠ¡åˆ†è§£

### é˜¶æ®µ1: åŸºç¡€æ¶æ„é‡å»º (2å‘¨)

#### 1.1 å‰ç«¯æ¶æ„é‡æ„
```bash
# æ–°å»ºNext.jsé¡¹ç›®
npx create-next-app@latest ai-writing-tool --typescript --tailwind --app
cd ai-writing-tool

# å®‰è£…æ ¸å¿ƒä¾èµ–
npm install zustand xstate @xstate/react
npm install @tiptap/react @tiptap/starter-kit @tiptap/extension-*
npm install framer-motion
npm install @trpc/client @trpc/server @trpc/next @trpc/react-query
```

#### 1.2 åç«¯æ¶æ„æ‰©å±•
```bash
# åœ¨ç°æœ‰backendåŸºç¡€ä¸Šæ‰©å±•
pip install redis celery
pip install asyncpg  # PostgreSQLå¼‚æ­¥é©±åŠ¨
pip install sentence-transformers  # æœ¬åœ°å¯è¯»æ€§æ£€æµ‹
```

#### 1.3 æ•°æ®åº“Schemaè®¾è®¡
```sql
-- æ–°å¢è¡¨ç»“æ„
CREATE TABLE workflow_documents (
    id UUID PRIMARY KEY,
    title VARCHAR(500) NOT NULL,
    content TEXT,
    status workflow_status_enum,
    config JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE workflow_nodes (
    id UUID PRIMARY KEY, 
    document_id UUID REFERENCES workflow_documents(id),
    type node_type_enum,
    status node_status_enum,
    content TEXT,
    metrics JSONB,
    parent_id UUID REFERENCES workflow_nodes(id),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE quality_metrics (
    id UUID PRIMARY KEY,
    node_id UUID REFERENCES workflow_nodes(id),
    readability_score FLOAT,
    grammar_errors INTEGER,
    citation_count INTEGER,
    word_count INTEGER,
    token_usage INTEGER,
    processing_time INTEGER
);

-- æšä¸¾ç±»å‹
CREATE TYPE workflow_status_enum AS ENUM (
    'idle', 'planning', 'drafting', 'citation_check', 
    'grammar_check', 'readability_check', 'done', 'failed'
);

CREATE TYPE node_type_enum AS ENUM (
    'Plan', 'Draft', 'Citation', 'Grammar', 'Readability', 'UserEdit', 'Plugin'
);

CREATE TYPE node_status_enum AS ENUM (
    'pending', 'running', 'pass', 'fail'
);
```

### é˜¶æ®µ2: å¾ªç¯å¼•æ“å¼€å‘ (3å‘¨)

#### 2.1 çŠ¶æ€æœºå®šä¹‰
```typescript
// frontend/lib/workflow-machine.ts
import { createMachine, assign } from 'xstate';

export const workflowMachine = createMachine({
  id: 'writing-workflow',
  initial: 'idle',
  context: {
    documentId: null,
    currentContent: '',
    nodes: [],
    config: {
      readabilityThreshold: 70,
      maxRetries: 3,
      autoRun: false
    }
  },
  states: {
    idle: {
      on: {
        START: {
          target: 'planning',
          actions: assign({
            documentId: (_, event) => event.documentId
          })
        }
      }
    },
    planning: {
      invoke: {
        src: 'planningService',
        onDone: {
          target: 'drafting',
          actions: assign({
            currentContent: (_, event) => event.data.outline
          })
        },
        onError: 'failed'
      }
    },
    drafting: {
      invoke: {
        src: 'draftingService', 
        onDone: {
          target: 'citationCheck',
          actions: assign({
            currentContent: (_, event) => event.data.content
          })
        },
        onError: 'failed'
      }
    },
    citationCheck: {
      invoke: {
        src: 'citationService',
        onDone: [
          {
            target: 'grammarCheck',
            cond: 'citationsPassed'
          },
          {
            target: 'drafting', // å›é€€é‡è¯•
            actions: 'incrementRetryCount'
          }
        ],
        onError: 'failed'
      }
    },
    grammarCheck: {
      invoke: {
        src: 'grammarService',
        onDone: [
          {
            target: 'readabilityCheck', 
            cond: 'grammarPassed'
          },
          {
            target: 'drafting',
            actions: 'incrementRetryCount'
          }
        ],
        onError: 'failed'
      }
    },
    readabilityCheck: {
      invoke: {
        src: 'readabilityService',
        onDone: [
          {
            target: 'done',
            cond: 'readabilityPassed'
          },
          {
            target: 'drafting',
            actions: 'incrementRetryCount'
          }
        ],
        onError: 'failed'
      }
    },
    done: {
      type: 'final'
    },
    failed: {
      on: {
        RETRY: 'planning',
        RESET: 'idle'
      }
    }
  }
});
```

#### 2.2 åç«¯å¾ªç¯å¼•æ“
```python
# backend/core/workflow_engine.py
from celery import Celery
from enum import Enum
import asyncio

class WorkflowEngine:
    def __init__(self, redis_url: str):
        self.celery = Celery('workflow', broker=redis_url)
        self.setup_tasks()
    
    def setup_tasks(self):
        @self.celery.task
        async def plan_document(document_id: str, user_prompt: str):
            """Plané˜¶æ®µ: ç”Ÿæˆæ–‡æ¡£å¤§çº²"""
            try:
                # è°ƒç”¨Claude APIç”Ÿæˆå¤§çº²
                outline = await self.llm_client.generate_outline(user_prompt)
                
                # ä¿å­˜èŠ‚ç‚¹
                node = await self.create_node(
                    document_id=document_id,
                    type="Plan", 
                    content=outline,
                    status="pass"
                )
                
                # è§¦å‘ä¸‹ä¸€æ­¥
                draft_document.delay(document_id, outline)
                return {"success": True, "outline": outline}
                
            except Exception as e:
                await self.mark_node_failed(document_id, "Plan", str(e))
                return {"success": False, "error": str(e)}
        
        @self.celery.task  
        async def draft_document(document_id: str, outline: str):
            """Drafté˜¶æ®µ: åŸºäºå¤§çº²ç”Ÿæˆå†…å®¹"""
            try:
                # ç”Ÿæˆå®Œæ•´å†…å®¹
                content = await self.llm_client.generate_content(outline)
                
                # ä¿å­˜èŠ‚ç‚¹
                node = await self.create_node(
                    document_id=document_id,
                    type="Draft",
                    content=content, 
                    status="pass"
                )
                
                # è§¦å‘å¼•ç”¨æ£€æŸ¥
                check_citations.delay(document_id, content)
                return {"success": True, "content": content}
                
            except Exception as e:
                await self.mark_node_failed(document_id, "Draft", str(e))
                return {"success": False, "error": str(e)}
        
        @self.celery.task
        async def check_citations(document_id: str, content: str):
            """Citationé˜¶æ®µ: éªŒè¯å’Œæ ¼å¼åŒ–å¼•ç”¨"""
            try:
                # æå–å¼•ç”¨
                citations = self.extract_citations(content)
                
                # éªŒè¯DOI
                validated_citations = []
                for citation in citations:
                    if citation.doi:
                        is_valid = await self.validate_doi(citation.doi)
                        if not is_valid:
                            # å¼•ç”¨éªŒè¯å¤±è´¥, å›é€€åˆ°Draft
                            await self.rollback_to_draft(document_id, "Invalid citation")
                            return {"success": False, "error": "Citation validation failed"}
                        validated_citations.append(citation)
                
                # æ ¼å¼åŒ–å¼•ç”¨
                formatted_content = self.format_citations(content, validated_citations)
                
                # ä¿å­˜èŠ‚ç‚¹
                node = await self.create_node(
                    document_id=document_id,
                    type="Citation",
                    content=formatted_content,
                    status="pass",
                    metrics={"citation_count": len(validated_citations)}
                )
                
                # è§¦å‘è¯­æ³•æ£€æŸ¥
                check_grammar.delay(document_id, formatted_content)
                return {"success": True, "content": formatted_content}
                
            except Exception as e:
                await self.mark_node_failed(document_id, "Citation", str(e))
                return {"success": False, "error": str(e)}
```

### é˜¶æ®µ3: UIç»„ä»¶é‡æ„ (3å‘¨)

#### 3.1 Layoutç»„ä»¶
```typescript
// app/layout.tsx - Holy Grailå¸ƒå±€
export default function WritingLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <div className="h-screen flex flex-col">
      {/* TopBar */}
      <TopBar />
      
      {/* ProcessBar */} 
      <ProcessBar />
      
      {/* Main Content */}
      <div className="flex-1 flex overflow-hidden">
        {/* Main Editor */}
        <main className="flex-1 px-[min(8%,120px)] py-8 overflow-y-auto">
          {children}
        </main>
        
        {/* Chat Panel */}
        <ChatPanel className="w-[24%] max-w-[380px] min-w-[300px] border-l" />
      </div>
    </div>
  )
}
```

#### 3.2 ProcessBarç»„ä»¶
```typescript
// components/ProcessBar.tsx
import { motion } from 'framer-motion'
import { useWorkflow } from '@/hooks/useWorkflow'

export function ProcessBar() {
  const { nodes, currentNode, rollbackToNode } = useWorkflow()
  
  return (
    <div className="h-12 pl-4 flex items-center gap-2 bg-gray-50 border-b sticky top-14 z-30">
      {nodes.map((node) => (
        <motion.div
          key={node.id}
          className={cn(
            "flex items-center gap-2 px-3 py-1 rounded-full cursor-pointer",
            {
              "bg-blue-100 text-blue-800": node.status === "running",
              "bg-green-100 text-green-800": node.status === "pass", 
              "bg-red-100 text-red-800": node.status === "fail",
              "bg-gray-100 text-gray-600": node.status === "pending"
            }
          )}
          whileHover={{ scale: 1.05 }}
          whileTap={{ scale: 0.95 }}
          onClick={() => rollbackToNode(node.id)}
        >
          <NodeIcon type={node.type} status={node.status} />
          <span className="text-sm font-medium">{node.type}</span>
          {node.status === "running" && (
            <motion.div
              className="w-4 h-4 border-2 border-current border-t-transparent rounded-full"
              animate={{ rotate: 360 }}
              transition={{ duration: 1, repeat: Infinity, ease: "linear" }}
            />
          )}
        </motion.div>
      ))}
    </div>
  )
}
```

#### 3.3 MainEditorç»„ä»¶
```typescript
// components/MainEditor.tsx
import { useEditor, EditorContent } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import { FloatingToolbar } from './FloatingToolbar'
import { PreviewOverlay } from './PreviewOverlay'

export function MainEditor() {
  const { content, previewContent, updateContent } = useWorkflow()
  const [selectedText, setSelectedText] = useState('')
  
  const editor = useEditor({
    extensions: [StarterKit],
    content,
    onUpdate: ({ editor }) => {
      updateContent(editor.getHTML())
    },
    onSelectionUpdate: ({ editor }) => {
      const { from, to } = editor.state.selection
      const text = editor.state.doc.textBetween(from, to)
      setSelectedText(text)
    }
  })

  return (
    <div className="relative prose max-w-none">
      <EditorContent editor={editor} />
      
      {/* æµ®åŠ¨å·¥å…·æ¡ */}
      {selectedText && (
        <FloatingToolbar 
          selectedText={selectedText}
          onAction={(action) => handleToolbarAction(action, selectedText)}
        />
      )}
      
      {/* é¢„è§ˆè¦†ç›–å±‚ */}
      {previewContent && (
        <PreviewOverlay 
          content={previewContent}
          onConfirm={() => acceptPreview(previewContent)}
          onReject={() => rejectPreview()}
        />
      )}
    </div>
  )
}
```

### é˜¶æ®µ4: å¼•ç”¨æ ¡éªŒç³»ç»Ÿ (2å‘¨)

#### 4.1 Redisç¼“å­˜å±‚
```python
# backend/core/citation_cache.py
import redis
import json
from typing import Optional

class CitationCache:
    def __init__(self, redis_url: str):
        self.redis = redis.from_url(redis_url, decode_responses=True)
        
    async def get_citation(self, doi: str) -> Optional[dict]:
        """ä»ç¼“å­˜è·å–å¼•ç”¨ä¿¡æ¯"""
        key = f"cite:{doi}"
        cached = self.redis.get(key)
        if cached:
            return json.loads(cached)
        return None
    
    async def set_citation(self, doi: str, citation_data: dict):
        """ç¼“å­˜å¼•ç”¨ä¿¡æ¯"""
        key = f"cite:{doi}"
        self.redis.setex(
            key, 
            7 * 24 * 3600,  # 7å¤©è¿‡æœŸ
            json.dumps(citation_data)
        )
    
    async def get_cache_stats(self) -> dict:
        """è·å–ç¼“å­˜ç»Ÿè®¡"""
        info = self.redis.info()
        return {
            "used_memory": info["used_memory_human"],
            "hit_rate": self.calculate_hit_rate(),
            "key_count": self.redis.dbsize()
        }
```

#### 4.2 DOIéªŒè¯æœåŠ¡
```python
# backend/services/citation_service.py
import httpx
from typing import List, Dict

class CitationService:
    def __init__(self, cache: CitationCache):
        self.cache = cache
        self.crossref_api = "https://api.crossref.org/works/"
        
    async def validate_doi(self, doi: str) -> bool:
        """éªŒè¯DOIæœ‰æ•ˆæ€§"""
        # å…ˆæ£€æŸ¥ç¼“å­˜
        cached = await self.cache.get_citation(doi)
        if cached:
            return cached.get("valid", False)
        
        # è°ƒç”¨CrossRef API
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(f"{self.crossref_api}{doi}")
                is_valid = response.status_code == 200
                
                # ç¼“å­˜ç»“æœ
                citation_data = {
                    "valid": is_valid,
                    "metadata": response.json() if is_valid else None
                }
                await self.cache.set_citation(doi, citation_data)
                
                return is_valid
                
            except Exception:
                return False
    
    async def format_citation(self, doi: str, style: str = "APA") -> str:
        """æ ¼å¼åŒ–å¼•ç”¨"""
        cached = await self.cache.get_citation(doi)
        if not cached or not cached["valid"]:
            return f"[Invalid Citation: {doi}]"
        
        metadata = cached["metadata"]["message"]
        
        if style == "APA":
            return self.format_apa(metadata)
        elif style == "GB/T":
            return self.format_gbt(metadata)
        else:
            return self.format_apa(metadata)
```

### é˜¶æ®µ5: è´¨é‡æ£€æµ‹ç³»ç»Ÿ (1.5å‘¨)

#### 5.1 å¯è¯»æ€§æ£€æµ‹
```python
# backend/services/readability_service.py
import textstat
from textstat import flesch_kincaid_grade

class ReadabilityService:
    
    def __init__(self, threshold: float = 70.0):
        self.threshold = threshold
    
    def calculate_score(self, text: str) -> dict:
        """è®¡ç®—å¯è¯»æ€§åˆ†æ•°"""
        # Flesch-Kincaid Grade Level
        fk_grade = flesch_kincaid_grade(text)
        
        # è½¬æ¢ä¸º0-100åˆ†æ•° (100-fk_grade*10, æœ€ä½0åˆ†)
        score = max(0, min(100, 100 - fk_grade * 10))
        
        # å…¶ä»–æŒ‡æ ‡
        avg_sentence_length = textstat.avg_sentence_length(text)
        difficult_words = textstat.difficult_words(text)
        word_count = textstat.lexicon_count(text)
        
        return {
            "score": score,
            "grade_level": fk_grade,
            "avg_sentence_length": avg_sentence_length,
            "difficult_words_ratio": difficult_words / word_count if word_count > 0 else 0,
            "word_count": word_count,
            "passed": score >= self.threshold
        }
    
    def get_improvement_suggestions(self, text: str, score_data: dict) -> List[str]:
        """ç”Ÿæˆæ”¹è¿›å»ºè®®"""
        suggestions = []
        
        if score_data["avg_sentence_length"] > 20:
            suggestions.append("å°è¯•ç¼©çŸ­å¥å­é•¿åº¦ï¼Œå¹³å‡å¥é•¿å»ºè®®æ§åˆ¶åœ¨15-20å­—")
            
        if score_data["difficult_words_ratio"] > 0.3:
            suggestions.append("å‡å°‘å¤æ‚è¯æ±‡ä½¿ç”¨ï¼Œç”¨æ›´å¸¸è§çš„è¯æ›¿æ¢ä¸“ä¸šæœ¯è¯­")
            
        if score_data["grade_level"] > 12:
            suggestions.append("é™ä½æ–‡ç« å¤æ‚åº¦ï¼Œä½¿ç”¨æ›´ç®€å•çš„å¥å¼ç»“æ„")
            
        return suggestions
```

### é˜¶æ®µ6: PWAç¦»çº¿åŠŸèƒ½ (1å‘¨)

#### 6.1 Service Workeré…ç½®
```typescript
// public/sw.js
const CACHE_NAME = 'ai-writing-tool-v1'
const urlsToCache = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/offline.html'
]

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => cache.addAll(urlsToCache))
  )
})

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then((response) => {
        // ç¼“å­˜å‘½ä¸­ï¼Œè¿”å›ç¼“å­˜
        if (response) {
          return response
        }
        
        // ç½‘ç»œè¯·æ±‚
        return fetch(event.request).catch(() => {
          // ç½‘ç»œå¤±è´¥ï¼Œè¿”å›ç¦»çº¿é¡µé¢
          if (event.request.destination === 'document') {
            return caches.match('/offline.html')
          }
        })
      })
  )
})
```

---

## ğŸ—‚ï¸ æ•°æ®è¿ç§»ç­–ç•¥

### ç°æœ‰æ•°æ®ä¿ç•™
```sql
-- ä¿ç•™ç°æœ‰ç”¨æˆ·æ•°æ®
INSERT INTO new_users SELECT * FROM users;

-- è¿ç§»æ–‡æ¡£æ•°æ®ï¼Œåˆ›å»ºå¯¹åº”çš„å·¥ä½œæµ
INSERT INTO workflow_documents (id, title, content, status, created_at)
SELECT 
    id,
    title, 
    content,
    'done'::workflow_status_enum,
    created_at
FROM documents;

-- ä¸ºæ¯ä¸ªç°æœ‰æ–‡æ¡£åˆ›å»ºä¸€ä¸ªUserEditèŠ‚ç‚¹
INSERT INTO workflow_nodes (document_id, type, status, content)
SELECT 
    id,
    'UserEdit'::node_type_enum,
    'pass'::node_status_enum, 
    content
FROM workflow_documents;
```

### æ¸è¿›å¼è¿ç§»
1. **é˜¶æ®µ1**: æ–°è€ç³»ç»Ÿå¹¶è¡Œè¿è¡Œï¼Œæ–°åŠŸèƒ½åœ¨æ–°ç³»ç»Ÿå¼€å‘
2. **é˜¶æ®µ2**: æä¾›æ•°æ®å¯¼å…¥å·¥å…·ï¼Œç”¨æˆ·ä¸»åŠ¨è¿ç§»
3. **é˜¶æ®µ3**: é€æ­¥ä¸‹çº¿è€ç³»ç»ŸåŠŸèƒ½æ¨¡å—
4. **é˜¶æ®µ4**: å®Œå…¨åˆ‡æ¢åˆ°æ–°ç³»ç»Ÿ

---

## âš ï¸ é£é™©æ§åˆ¶

### æŠ€æœ¯é£é™©
- **å¤æ‚åº¦æš´å¢**: å¼•å…¥çŠ¶æ€æœºå¢åŠ è°ƒè¯•éš¾åº¦
  - *ç¼“è§£*: å®Œå–„æ—¥å¿—å’Œå¯è§†åŒ–è°ƒè¯•å·¥å…·
- **æ€§èƒ½ç“¶é¢ˆ**: å¾ªç¯å¤„ç†å¯èƒ½é•¿æ—¶é—´å ç”¨èµ„æº  
  - *ç¼“è§£*: ä»»åŠ¡é˜Ÿåˆ—+è¶…æ—¶æœºåˆ¶+èµ„æºç›‘æ§
- **æ•°æ®ä¸€è‡´æ€§**: å¹¶å‘ä¿®æ”¹å’Œå›æ»šå¯èƒ½å¯¼è‡´æ•°æ®å†²çª
  - *ç¼“è§£*: ä¹è§‚é”+äº‹åŠ¡+å†²çªæ£€æµ‹

### ä¸šåŠ¡é£é™©  
- **ç”¨æˆ·æ¥å—åº¦**: ç•Œé¢å’Œäº¤äº’æ–¹å¼å®Œå…¨æ”¹å˜
  - *ç¼“è§£*: æ¸è¿›å¼å‘å¸ƒ+ç”¨æˆ·åŸ¹è®­+å¿«é€Ÿåé¦ˆ
- **APIæˆæœ¬**: å¾ªç¯è°ƒç”¨å¯èƒ½å¤§å¹…å¢åŠ è´¹ç”¨
  - *ç¼“è§£*: æ™ºèƒ½ç¼“å­˜+æœ¬åœ°æ¨¡å‹+ç”¨é‡ç›‘æ§

### é¡¹ç›®é£é™©
- **å¼€å‘å‘¨æœŸ**: 12å‘¨é‡æ„æ—¶é—´å¯èƒ½ä¸å¤Ÿ
  - *ç¼“è§£*: MVPä¼˜å…ˆ+å¹¶è¡Œå¼€å‘+çµæ´»è°ƒæ•´
- **å›¢é˜Ÿè´Ÿè·**: åŒæ—¶ç»´æŠ¤æ–°è€ä¸¤å¥—ç³»ç»Ÿ
  - *ç¼“è§£*: åˆç†åˆ†å·¥+æŠ€æœ¯å€ºåŠ¡ç®¡ç†

---

## ğŸ“ˆ æˆåŠŸæ ‡å‡†

### é‡Œç¨‹ç¢‘éªŒæ”¶æ ‡å‡†
- **M0**: æ–°æŠ€æœ¯æ ˆåŸºç¡€ç¯å¢ƒæ­å»ºå®Œæˆï¼ŒåŸºæœ¬APIå¯ç”¨
- **M1**: å¾ªç¯å¼•æ“æ ¸å¿ƒæµç¨‹è·‘é€šï¼Œèƒ½ç”Ÿæˆå®Œæ•´æ–‡æ¡£
- **M2**: æ–°UIç•Œé¢å®Œæˆï¼Œç”¨æˆ·å¯æ­£å¸¸æ“ä½œ
- **M3**: å¼•ç”¨æ ¡éªŒç³»ç»Ÿé›†æˆï¼Œç¼“å­˜å‘½ä¸­ç‡>95%
- **M4**: PWAåŠŸèƒ½å®Œæ•´ï¼Œç¦»çº¿å¯ç”¨

### æœ€ç»ˆéªŒæ”¶æ ‡å‡†
- [ ] ç”¨æˆ·å¯é€šè¿‡ä¸€æ¡æŒ‡ä»¤ç”Ÿæˆ2000å­—æ–‡ç« 
- [ ] å¯è¯»æ€§æ£€æµ‹å‡†ç¡®ç‡>95%
- [ ] ç³»ç»Ÿå“åº”æ—¶é—´<150ms  
- [ ] å¼•ç”¨éªŒè¯å‡†ç¡®ç‡>99%
- [ ] PWAç¦»çº¿åŠŸèƒ½å®Œæ•´å¯ç”¨

---

**é‡æ„è®¡åˆ’æ€»ç»“**: è¿™æ˜¯ä¸€æ¬¡äº§å“å½¢æ€çš„æ ¹æœ¬æ€§è½¬å˜ï¼Œä»å¤šåŠŸèƒ½åŠ©æ‰‹åˆ°ä¸“ä¸šå†™ä½œå·¥å…·ã€‚éœ€è¦12å‘¨æ—¶é—´ï¼Œåˆ†6ä¸ªé˜¶æ®µé€æ­¥å®Œæˆã€‚å…³é”®æ˜¯ä¿è¯ç”¨æˆ·ä½“éªŒçš„è¿ç»­æ€§å’Œæ•°æ®çš„å®‰å…¨è¿ç§»ã€‚